获取帮助的地方，优先级从上到下：
--help命令（脚本或命令 --help）
脚本里的注释
程序自带文档
man 脚本名





程序运行：
一。& 最经常被用到
这个用在一个命令的最后，可以把这个命令放到后台执行
二。ctrl + z
可以将一个正在前台执行的命令放到后台，并且暂停
三。jobs
查看当前有多少在后台运行的命令
四。fg
将后台中的命令调至前台继续运行
如果后台中有多个命令，可以用 fg %jobnumber将选中的命令调出，%jobnumber是通过jobs命令查到的后台正在执行的命令的序号(不是pid)
五。bg
将一个在后台暂停的命令，变成继续执行
如果后台中有多个命令，可以用bg %jobnumber将选中的命令调出，%jobnumber是通过jobs命令查到的后台正在执行的命令的序号(不是pid)







yum,rpm
rpm -ql mysql   查看yum安装位置
yum repolist all  查看yum源列表
yum grouplist     查看已安装和可安装的工具包group
（?centos的一些版本没有源
yum install epel-release 
ls -lah /etc/yum.repos.d/
(？rpm -e epel-release
如果ls -lah /etc/yum.repos.d/找不到epel源，说明之前有安装脏
需要rpm -e epel-release
再yum install epel-release
）
 yum remove mod_wsgi    yum删除
 
 rpm:
 -e, --erase=<package>+           erase (uninstall) package   删除
 -i, --install                    install package(s)          安装
 -v, --verbose                    provide more detailed output
 -h, --hash                       print hash marks as package installs (good with -v)
 -l, --list                       list files in package(with -q)
 -U, --upgrade=<packagefile>+     upgrade package(s)          升级
 -a, --all                        query/verify all packages
 -q                                                           查询
 安装，升级，删除，查询可组合其他命令选项使用，例子：
 rpm -q logstash                         查看某个包是否被安装
 rpm -qa logstash                        列出所有已安装的rpm包
 rpm -ql mysql                           查看安装位置
 rpm -ivh logstash-2.1.1-1.noarch.rpm    安装某个rpm软件包
 rpm -Uvh logstash-2.1.1-1.noarch.rpm    升级某个rpm包
 rpm -e epel-release                     卸载某个已用rpm方式安装的软件
 









环境配置

系统相关
set命令显示当前shell的变量，包括当前用户的变量;
env命令显示当前用户的变量;
export命令显示当前导出成用户变量的shell变量。

echo $PATH
which python
ln -s /usr/local/bin/python2.7 /usr/bin/python
(把后者链到前者，使用后者实际上就是使用前者，再比如/data有空间 /opt无空间 就可以 ln -s /data/storage /opt/storage
 当向/opt/storage里写入时 实际上就是向/data/stroage里写入
)

vim .bashrc
export GOPATH=$HOME/go   //the go path

vim  /etc/profile文件 （全局所有用户）
export GOPATH=$HOME/go 
编辑完/etc/profile文件后，需要执行 source /etc/profile 使之生效


语言举例：
whereis java
which java （java执行路径）


go语音相关：
go  env  //the go language env

php环境查看
可echo出phpinfo()这个函数
php环境配置
cd php-5.6.11/ext/zip
/data1/php/bin/phpize
./configure --with-php-config=/data1/php/bin/php-config

apache相关
apachectl -V   //查看编译设置


配置JAVA_HOME举例
 查看rpm方式安装的程序路径：
 [root@i-be9r027r jvm]# rpm -qa | grep java
java-1.8.0-openjdk-1.8.0.51-1.b16.el6_7.x86_64
java-1.8.0-openjdk-headless-1.8.0.51-1.b16.el6_7.x86_64
java-1.7.0-openjdk-1.7.0.91-2.6.2.2.el6_7.x86_64
tzdata-java-2015f-1.el6.noarch
[root@i-be9r027r jvm]# 
[root@i-be9r027r jvm]# rpm -ql java-1.7.0-openjdk

推导安装路径：
[root@i-be9r027r jvm]# which java
/usr/bin/java
[root@i-be9r027r jvm]# ls -lah /usr/bin/java
lrwxrwxrwx 1 root root 22 Jan 14 19:34 /usr/bin/java -> /etc/alternatives/java
[root@i-be9r027r jvm]# ls -lah /etc/alternatives/java
lrwxrwxrwx 1 root root 46 Jan 14 19:34 /etc/alternatives/java -> /usr/lib/jvm/jre-1.7.0-openjdk.x86_64/bin/java

编辑/etc/profile文件
/usr/lib/jvm/java-1.7.0-openjdk-1.7.0.91.x86_64/jre  （这个机器应该有调整，JDK的路径较怪异）
执行source /etc/profile命令
echo $JAVA_HOME 验证是否配置成功








ssh
1.在A机下生成公钥/私钥对。
[chenlb@A ~]$ ssh-keygen -t rsa -P ''
2.把A机下的id_rsa.pub复制到B机下，在B机的.ssh/authorized_keys文件里，我用scp复制。
[chenlb@A ~]$ scp .ssh/id_rsa.pub chenlb@192.168.1.181:/home/chenlb/id_rsa.pub 
3.B机把从A机复制的id_rsa.pub添加到.ssh/authorzied_keys文件里。
[chenlb@B ~]$ cat id_rsa.pub >> .ssh/authorized_keys      （这一步有可能加入文件内后，没有换行，导致不生效，注意检查）
[chenlb@B ~]$ chmod 600 .ssh/authorized_keys             （这一步不要忘了）
脚本：
for i in 1 2 3;do ssh-keygen -t rsa -P '';echo $i;scp .ssh/id_rsa.pub root@xx.xx.xx.$i:/root/id_rsa.pub;
ssh xx.xx.xx.$i "cat /root/id_rsa.pub >> .ssh/authorized_keys";echo $i;done

ssh非密码形式，文件钥形式：
ssh  -i  ~/.ssh/keyfile  root@xxx.xxx.xxx.xxx







跟踪
tcpdump -i bond0 port 8085 -s 0 -w - | strings







常用命令

groupadd hadoop
useradd hadoop -g hadoop

scp
“scp”调用SSH进行登录，然后拷贝文件，最后调用SSH关闭这个连接。
scp -i ~/.ssh/dev-key .ssh/id_rsa.pub root@xxx.xxx.xxx.xxx:/root/id_rsa.pub（文件钥形式）
scp .ssh/id_rsa.pub root@xxx.xxx.xxx.xxx:/home/sk77/id_rsa.pub（密码形式）


kill
kill -term(-15)   关闭程序，给程序资源回收的机会和时间
kill -kill(-9)    直接强制杀死
kill -0           Check access to pid  通常可在编写脚本时使用，用以检查进程是否运行
参考文档：http://www.cyberciti.biz/faq/unix-kill-command-examples/
通常，应该发送15，等一两秒钟，如果没效果，发送2，如果还不行，发送1。如果还不行，那你应该把那个程序删掉，因为那个程序写的太烂了！
不要使用kill -9。不要用收割机来修剪花盆里的花。
总之，在使用kill -9前，你应该先使用kill -15，给目标进程一个清理善后工作的机会。(进程也许无法捕捉或直接忽略SIGKILL信号，但它们可以，
通常也是能够捕捉SIGTERM信号的。)如果你不留机会让进程完成清理工作，它们会留下一些不完整的文件或状态，当系统重启时，
程序将无法理解这些状态。
strace/truss，ltrace和gdb都是查看一个卡住的进程因何卡住的好工具。(Solaris里的truss -u非常好用；)Solaris里还有一些
非常有用的/proc相关的工具，有一些已经被移植到了Linux上。


所谓的将程序重启，比如logstash，也就是
stop && start,也就是
kill -15 pid &&  /opt/logstash/bin/logstash agent -f ${LS_CONF_DIR} -l ${LS_LOG_FILE} ${LS_OPTS}








硬件

硬盘：
/etc/fstab    fsck、mount、umount的等命令都利用该程序
fdisk -l      
df -h
